---
id: interrupts
title: Interrupts in x86
sidebar_label: Interrupt Handling
---


Interrupts in the x86 architecture are a mechanism that allows the CPU to respond to asynchronous or synchronous events. These events can originate from hardware devices, software, or exceptional conditions during execution. By pausing the current execution flow, saving the processor state, and transferring control to a designated interrupt handler, interrupts enable the system to address critical tasks like I/O operations, system calls, or error handling.

---

## Types of Interrupts

### 1. **Hardware Interrupts**
- Triggered by external hardware devices, such as keyboards, timers, or network interfaces, via the Programmable Interrupt Controller (PIC) or APIC.
- Examples include:
  - Timer interrupts
  - Keyboard input

### 2. **Software Interrupts**
- Explicitly triggered by the `INT` instruction in software.
- Often used for system calls, allowing user programs to request services from the kernel.
  - For example, `INT 0xA` is commonly used for write operations.

### 3. **Exceptions**
- Synchronous interrupts triggered by exceptional conditions during execution, such as divide-by-zero errors or invalid memory access.
- Examples include:
  - **Divide Error (INT 0):** Triggered by division by zero.
  - **Page Fault (INT 14):** Occurs when the MMU detects a memory access violation.

---

## Interrupt Descriptor Table (IDT)

The x86 CPU uses the Interrupt Descriptor Table (IDT) to map interrupt vectors to their corresponding handlers. The IDT contains 256 entries, each describing a handler's attributes, such as its base address, segment selector, and privilege level. 

### Steps when an Interrupt Occurs:
1. The CPU uses the interrupt vector to look up the corresponding IDT entry.
2. It loads the handler's code segment and offset, transferring control to the handler.

---

## Handling Interrupts

When an interrupt is triggered, the CPU performs the following steps:

1. **Saves the Current State:**
   - Pushes the `EIP` (instruction pointer), `CS` (code segment), and `EFLAGS` onto the stack.
   - If a privilege level change occurs (e.g., user to kernel), it also saves the stack pointer (`ESP`) and stack segment (`SS`).

2. **Disables Further Interrupts:**
   - By clearing the Interrupt Flag (IF) in `EFLAGS`, the CPU ensures atomicity during the handler's execution.

3. **Executes the Handler:**
   - The CPU jumps to the interrupt handler, where the necessary processing is performed.

4. **Restores the State:**
   - The handler uses the `IRET` instruction to restore the saved state and resume the interrupted program.

---

## IDT Entry Structure

```c
// Structure for an IDT entry (Interrupt Descriptor Table Entry)
struct IDTEntry {
    uint16_t offset_1;        // Offset bits 0..15
    uint16_t selector;        // A code segment selector in GDT or LDT
    uint8_t  zero;            // Unused, set to 0
    uint8_t  type_attributes; // Gate type, DPL, and P fields
    uint16_t offset_2;        // Offset bits 16..31
} __attribute__((packed));

// Structure for the IDT pointer
struct IDTPointer {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

// Declare the IDT and IDT pointer as global variables
struct IDTEntry idt[256];
struct IDTPointer idtp;
```

---

## Interrupt Handler Functions and Mapping

Interrupt handler functions are specific routines invoked in response to interrupts, whether generated by hardware, software, or exceptions. These functions are typically part of the operating system's kernel and perform tasks such as acknowledging hardware requests, processing input, or handling critical errors. 

### Mapping of Interrupt Handlers
- The IDT is a structure with 256 entries, each corresponding to an interrupt vector. 
- Each entry defines the attributes of an interrupt handler, including:
  - The base address of the handler function.
  - The segment selector pointing to the code segment where the handler resides.
  - Access control flags, such as privilege level (DPL) and type (interrupt gate, trap gate, or task gate).

---

## Why Assembly is Used First?

**Problem:**  
C code alone cannot handle all aspects of interrupt handling, such as saving the CPU state or switching privilege levels. Direct CPU instructions like `IRET` (used to return from interrupts) must be written in assembly as they are not directly accessible in C.

**Solution:**  
Write a small assembly stub that:
- Saves the CPU state.
- Calls the C function for handling the interrupt.
- Restores the state and uses the `IRET` instruction to return.

---

## Example: Interrupt Handlers for INT 0 and INT 1

### Assembly Handlers:
```asm
interrupt1:
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    call int1
    mov ax, 0x23
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    iret

interrupt0:
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    call int0
    mov ax, 0x23
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    iret
```

### C Functions:
```c
void int_0() {
    char *video_memory = (char *)0xb8000;
    *video_memory = '0';
    __asm__("iret");
}

void int_1() {
    char *video_memory = (char *)0xb8000;
    *video_memory = '1';
    __asm__("iret");
}
```

---

## Setting Up the IDT

### LIDT Instruction
The `LIDT` (Load Interrupt Descriptor Table) instruction is used to load the base address and limit of the IDT into the CPU's IDTR (Interrupt Descriptor Table Register). This setup is performed during system initialization to define handlers for interrupts and exceptions. 

### Setting Up IDT Entries
```c
void setUpIntDesc(int i, uintptr_t func_addr, uint16_t selector, uint8_t type_attributes) {
    idt[i].offset_1 = func_addr & 0xFFFF;         // Lower 16 bits
    idt[i].offset_2 = (func_addr >> 16) & 0xFFFF;
    idt[i].selector = selector;
    idt[i].zero = 0x0;
    idt[i].type_attributes = type_attributes;
}

void setUpIntDescTable() {
    idtp.limit = (uint16_t)(sizeof(idt) - 1);
    idtp.base = (uint32_t)&idt;

    // Inline assembly to load the IDT using lidt
    asm volatile ("lidt (%0)" : : "r" (&idtp));

    // Set up interrupt descriptors
    setUpIntDesc(0, (uintptr_t) interrupt0, 0x08, 0xEF);
    setUpIntDesc(1, (uintptr_t) interrupt1, 0x08, 0xEF);
    	return;
}
```

